## HTTP报文
浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文     

与缓存相关的规则信息，都包含在header中
- 包含属性的首部(header)--------------------------附加信息（cookie，缓存信息等）
- 包含数据的主体部分(body)-----------------------HTTP请求真正想要传输的部分

## 强缓存与对比缓存
HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)

强缓存首先向缓存数据库请求数据，若存在数据，则直接返回数据，不需要向服务器请求数据；      
若不存在，则向服务器请求数据，数据返回到客户端后再将数据和缓存规则存入缓存数据库。    

对比缓存也是先向缓存数据库请求数据，但其从缓存数据库先获得的是缓存数据的标识，拿到标识后向服务器询问对应的数据是否失效，未失效客户端则向缓存数据库请求数据；若服务器回答标识已失效，服务器则会返回最新数据和缓存规则，客户端拿到最新数据和缓存规则再将其存入缓存数据库。

> 不同点： 强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。
> 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行 对比缓存规则


### 强制缓存

强制缓存响应header中会有两个字段来标明失效规则（Expires/Cache-Control）Network会标明缓存来源（from disk cache）

#### Expires
　Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。

不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。

另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。

所以HTTP 1.1 的版本，使用Cache-Control替代。

#### Cache-Control
常见取值

- private:             客户端可以缓存（默认）
- public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
- max-age=xxx:        缓存的内容将在 xxx 秒后失效
- no-cache:          必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求
- no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发（隐私情况用）


### 对比缓存

对比缓存生效时，状态码为304（文件已存在1），且报文大小和请求时间大大减少

原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。

与强缓存不同的是，缓存标识的传递，其中，缓存标识分为`Last-Modified ` /  `If-Modified-Since`两种

- Last-Modified：
  服务器在响应请求时，告诉浏览器资源的最后修改时间。

- If-Modified-Since：
再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。          
服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。      
若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；        
若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

  `Etag`  /  `If-None-Match`（优先级高于`Last-Modified`  /  `If-Modified-Since`）


- 通过 `ETag` 验证缓存的响应
  服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

- If-None-Match：
  再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。        
  服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，     
  不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；       
  相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。       

### 浏览器第一次请求

浏览器请求 -> 无缓存 -> 向服务器请求 -> 响应请求，缓存协商 -> 呈现    

> 缓存标识
  1. 是否缓存 Expires、Cache-Control      
  2. 缓存时间       
  3. Etag       
  4. Last-Modified      
  5. 等等       


### 浏览器第二次请求
![浏览器第二次请求](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)
## 总结

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。

对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)

[Web Fundamentals](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)


# 制定缓存策略

  根据通信模式、提供的数据类型以及应用特定的数据更新要求，为每个资源定义和配置合适的设置

- **使用一致的网址**：如果在不同的网址上提供相同的内容，将会多次提取和存储这些内容。 tips：网址区分大小写。

- **确保服务器提供验证令牌 (ETag)**：有了验证令牌，当服务器上的资源未发生变化时，就不需要传送相同的字节。

- **确定中间缓存可以缓存哪些资源**：对所有用户的响应完全相同的资源非常适合由 CDN 以及其他中间缓存进行缓存。

- **为每个资源确定最佳缓存周期**：不同的资源可能有不同的更新要求。 为每个资源审核并确定合适的`expired-time` `max-age`。

- **确定最适合的网站的缓存层次结构**：可以通过为 HTML 文档组合使用包含内容指纹的资源网址和短时间或 no-cache 周期，来控制客户端获取更新的速度。

- **最大限度减少搅动**：某些资源的更新比其他资源频繁。 如果资源的特定部分（例如 JavaScript 函数或 CSS 样式集）会经常更新，可以考虑将其代码作为单独的文件提供。 这样一来，每次提取更新时，其余内容（例如变化不是很频繁的内容库代码）可以从缓存提取，从而最大限度减少下载的内容大小。

