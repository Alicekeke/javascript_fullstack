### 大文件上传与断点续传

- http 请求可并发，大文件分为 n 个切片并发上传，速度更快，改善用户体验。
- file.slice()支持文件切片，切片后 Blob 类型对象，即二进制文件类型。
- es6 后 Blob 协议 支持文件传送到服务器之前就可以提前预览。

### 切片上传 Blob 解决什么问题？

- 传统 es5 时代， 文件只有上传到服务器后，由服务器提供远程地址，才能够看到我们上传的这个文件。
- es6 在本地客户端操作文件的能力，file 对象，Blob 协议在本地就立刻显示出来我们上传的这个文件，并配上进度条，提高用户体验，这才是前端要做的东西。

### 大文件切片上传的顺序

1. 把大文件切片化 => file 是 Blob 类的实例 Blob.prototype.slice 可以把一个文件切换处理，HTTP 可以多个并发传递 6~7 次
2. 等切片都上传完，将切片传输给服务器，再向服务器发送一个合并图片的请求

### 提前预览

URL 对象：构建出 Blob 协议的 URL 并生成本地 url 以供预览。  
`pic.onload = url.revokeObjectURL(objectURL)` 在显示后释放本地缓存，以获得最佳性能和内存使用状态，不然就要等到窗口关闭时才能释放资源

### 前端 http 并发上传大文件切片

    formData异步上传文件

### 后端接收切片

    使用multiparty包解析前端传来的formData

    跨域的解决方法 ———— cors设置请求头
    用代码把chunk存在target中 ，使用fs-extra操作chunk

### 合并切片

功能点： 将切片上传好的根据哈希值找到对应的目录，合并为一个图片 ，
stream 流 分为可读流和可写流，每一个切开的 chunk 都是一个二进制流文件。  
Promise.all 来包装每个 chunk 的写入 。
**每个 chunk 的写入，都是先创建可读流，再 pipe 给可写流的过程**
思路：以源文件作为文件夹的名字，在上传 blobs 到这个文件夹，并且每个 blob 都以'文件-index'的命名方式来存储
