js 
- 语法分析
- 预编译
- 解释执行


## 作用域精解
- [scope]:
   每个js函数都是一个对象，对象中有些属性我们可以访问，有些不可以，这些属性仅供js引擎存取，[scope]就是其中一个, 隐式的，我们不能拿出来用
[scope]就是作用域，存储了运行期上下文的集合{AO，GO}

- 作用域链：
  [scope]中所存储的执行期上下文对象的集合，该集合呈链式链接，这种链式链接叫做作用域链

- 执行期上下文
  当函数执行时(前一刻)即(预编译)，会创建一个称为执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境。函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕其所产生的执行期上下文被销毁(AO)。

- 查找变量：从当前函数作用域链的顶端依次向下查找，先找自己的AO、再外部AO、再找GO  
  
- 函数执行生成一个全新的执行期上下文并加到自己作用域链的最顶端，并保存外部函数的作用域链，形成一个完整的作用域，链等待被查找的过程
  
  eg
  ```
  function a(){
    function b(){

    }
    b()
  }
  a()

  a.defined a.[[scope]] --> 0:GO
  a.doing a.[[scope]] --> 0: aAO    
                          1: GO
  b.defined b.[[scope]] --> 0: aAO    //a执行导致b定义， b拿到a的作用域链
                            1: GO
  d.doing   b.[[scope]] --> 0:bAO   //b执行生成自己的AO，防在作用域链的最顶端
                            1:aAO
                            2:GO    //aAO在a、b作用域链都是一样的，都只是拿过来引用
  ```

### 预编译前奏
1. imply global： 暗示全局变量，即任何变量若未经声明就赋值，此变量就为全局对象所有
2. 一切声明的全局变量，全是window的属性

### 预编译
预编译发生在函数执行的前一刻
函数声明整体完全提升：系统会把函数提到逻辑最前面
变量   声明提升

### 预编译四部曲
函数体内的预编译
1. 创建AO(Activation Object) : **执行期上下文**
2. 找形参和变量声明，将变量和形参作为AO的属性名，值为undefined
3. 将实参值与形参统一,接受实参，添加到AO的属性，覆盖之前的undefined
4. 在函数体内找函数声明，将函数名作为AO对象的属性名，值赋予函数体

```
 function fn(a){
      console.log(a) //function a(){}
      var a = 123
      console.log(a)  //123
      function a(){}
      console.log(a)  //123
      var b = function(){}
      console.log(b)  //function(){}
      function d(){}
    }
    fn(1)
      // AO{
        // a: undefined -> 1 -> function a(){} --执行--> 123
        // b:undefined --执行--> function(){}
        // d: function d(){}
    // }
```
 -------------------------------------
```
        global=100
        function f(){
          console.log(global)  //undefined;  这里AO已经有gobal，值为undefined，所以不会从GO里拿
          global=200
          console.log(global)  //200
          var global=300
        }
        f()
        var global
        // AO:{
        //   global:undefined->200

        // }
        // GO:{
        //   global:undefined->100
        // }
```

 > 函数声明、函数表达式、
- 函数声明 -->  function a(){} 
- 函数表达式 --> var a = function(){}
  
函数声明与函数表达式之间最重要的区别是他们的名称标识符被绑定在何处
函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用

> 匿名函数、具名函数
- 命名函数表达式  --> var a = function a(){}
- 具名函数表达式 --> var a = function(){}

匿名函数表达式在回调参数时用的多，其他情况还是具名比较好，便于栈追踪，提高代码可读性  

弱数据类型(解释性)语言永远不输出地址

--------------------------------------------------------
#### 预编译也发生在全局
1. 创建GO对象
2. 找形参和变量声明，将变量和形参作为AO的属性名，值为undefined
3. 在函数体找函数声明，将函数名作为AO对象的属性名，值赋予函数体

GO（全局作用域） === window 

先生成GO，在生成AO

字符串参与加减乘除运算自动隐式转换为数字

只有函数执行，系统才会解释函数中的代码


 ### 闭包

#### 当内部函数被保存到外部时，将会产生闭包；闭包会导致原有作用域链不释放，作用域无法被回收，造成内存泄露

#### 闭包可以实现公有变量
- 闭包的运用
  1. 函数累加器
  2. 做缓存(存储结构)
  3. 私有化变量，实现封装
  4. 模块化开发，防止污染全局变量
多人协作，不能定义公有化变量，模块化，高内聚

方法中有多个方法都被保存在外部调用，所保存出的作用域都是一样的


#### 立即执行函数
  (function(){}())
- 作用：立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量





