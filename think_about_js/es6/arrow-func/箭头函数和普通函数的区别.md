### 0.箭头函数可以简化代码
  箭头函数最常见的用处就是简化回调函数。
  ```js
  // 正常函数写法
  [1,2,3].map(function (x) {
    return x * x;
  });

  // 箭头函数写法
  [1,2,3].map(x => x * x);
  ```
  好短，和python一样短

### 1. 箭头函数不会创建自己的this

   箭头函数在定义时就继承了外层的this值，并且之后也不会被改变，所有可以避免this指向丢失的问题

### 2. 箭头函数继承而来的this指向永远不变
```js
var id = 'GLOBAL';
var obj = {
  id: 'OBJ',
  a: function(){
    console.log(this.id);
  },
  b: () => {
    console.log(this.id);
  }
};

obj.a();    // 'OBJ'
obj.b();    // 'GLOBAL'

```
上面这个例子，对象obj的方法a使用**普通函数**定义的，普通函数作为对象的方法调用时，**this指向它所属的对象**      
b用箭头函数定义，那么他的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象，（真好，和promise一样让我感动，这年头，说到做到，实现承诺的太少了😥）         

### 3. call、apply、bind无法修改this指向，咋修都不行，硬要修也不给你报错

### 4. 箭头函数不能作为构造函数使用

  new一个对象的时候发生了什么？
  1. JS内部首先会先生成一个空对象； 
  2. 再把函数中的this指向该对象； 
  3. 然后执行构造函数中的语句；
  4. 最终返回该对象实例。

  对，因为箭头函数天生没有自己的this，它的this其实是继承了外层执行环境中的this，    
  且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，    
  像这样构造函数用箭头函数      
  ```js 
  const person = (age, name) => {
    this.name = XXX
    this.age = YYY
  }
  ```
  你见过这样的代码？箭头函数自己的this都直的不得了，还想掰弯别人？      

### 6. 箭头函数没有自己的arguments
     箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。